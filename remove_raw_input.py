import sys
import timeit
import binascii

# Suffix Trie implementation. Uses nested maps as primary data structure.


class SuffixTrie(object):
    """  suffix trie generation of a provided string t """

    # Initializer function, with terminator indicator and antiword indicator for any given node
    def __init__(self, t):
        """ Make suffix trie from t """
        t += '$'  # terminator symbol
        antiword = '%'
        self.root = {}
        for i in range(len(t)):  # for each suffix
            cur = self.root
            for c in t[i:]:  # for each character in i'th suffix
                if c not in cur:
                    cur[c] = {}  # add outgoing edge if it is needed
                cur = cur[c]

    def follow_path(self, s):
        """ Follow a path of given characters of s.  Return node at
            end of path, or None if we fall off. """
        cur = self.root
        for c in s:
            if c not in cur:
                return None  # no outgoing edge on next character
            cur = cur[c]  # descend one level
        return cur

    # Test if s is a substring of the word represented by this suffix

    def has_substring(self, s):

        """ Return true if s appears as a substring of t """

        return self.follow_path(s) is not None

    # Test if s is a suffix of the word represented by this suffix

    def has_suffix(self, s):

        """ Return true if s is a suffix of t """

        node = self.follow_path(s)

        # $ is an indicator for a terminal symbol

        return node is not None and '$' in node

    # Test if s is an antifactor of the word represented by this trie.

    def is_af(self, s):

        """ Return true if s is a af of t """

        node = self.follow_path(s)

        return node is not None and '%' in node

    # Graphical representation of the suffix trie generated by the word given.
    def to_dot(self):

        """ Return dot representation of trie to make a picture """

        lines = []

        def _to_dot_helper(node, parid):
            childid = parid
            for c, child in node.items():
                lines.append('  %d -> %d [ label="%s" ];' % (parid, childid + 1, c))
                childid = _to_dot_helper(child, childid + 1)
            return childid

        lines.append('digraph "Suffix trie" {')
        lines.append('  node [shape=circle label=""];')
        _to_dot_helper(self.root, 0)
        lines.append('}')
        return '\n'.join(lines) + '\n'

    # Convert this suffix trie into an antidictionary. Works by traversing and
    # finding all inputs not accepted, adding them as antifactors to the map.
    def convert_AD(self):
        cur = self.root
        myQueue = []
        myQueue.append(cur)

        # Using breadth-first search with a queue data structure
        while (len(myQueue) is not 0):

            # If a transition on 0 exists, we add it to the queue to explore its' children
            if '0' in myQueue[0]:
                myQueue.append(myQueue[0]['0'])

            # If no transition on 0 exists, we add a transition for 0 to a antifactor
            # state, and mark it with special symbol '%' to represent the node being an antifactor.
            elif '0' not in myQueue[0]:
                myQueue[0]['0'] = {}
                temp = myQueue[0]['0']
                temp['%'] = {}

            # Likewise, if a transition on 1 exists,
            #  we add it to the queue to explore its' children
            if '1' in myQueue[0]:
                myQueue.append(myQueue[0]['1'])

            # We also add transitions for 1 if it doesn't exist.
            elif '1' not in myQueue[0]:
                myQueue[0]['1'] = {}
                temp = myQueue[0]['1']
                temp['%'] = {}

            # Finally, pop current node from the queue, and examine the next.
            myQueue.pop(0)


# Encode function takes an antidictionary and a word to encode, and returns the encoded
# Version.
def encode(ad, myT):
    encoded = ""
    curPrefix = ""
    encoded += myT[0]
    curPrefix += myT[0]

    for i in myT[1:]:
        # print("Cur prefix: ", curPrefix)
        # print("Cur encoded: ", encoded)
        testA = curPrefix
        testA += '0'
        if (ad.is_af(testA) == True):
            # print(testA, "There is a word ", testA, " in AD")
            curPrefix += i
            # print("so curprefix is now", curPrefix)
            continue
        testB = curPrefix
        testB += '1'
        if (ad.is_af(testB) == True):
            # print(testB, "is af")
            # print(testB, "There is a word ", testB, " in AD")
            curPrefix += i
            continue
        # print("No such word, read from input push to output")
        curPrefix += i
        encoded += i

    print("Encoded: {}".format(encoded))
    return encoded


def decode(ad, lenInput, encoded):
    decoded = encoded[0]
    curPrefix = encoded[0]
    encoded = encoded[1:]
    for i in range(1, lenInput):
        # print("curPrefix:",curPrefix)
        # print("decoded:",decoded)
        testA = curPrefix
        testA += '0'

        '''
        There is a word in the AD with prefix'0, so erase the next symbol
        '''
        if ad.is_af(testA):
            # print("is a word:",testA)
            decoded += '1'
            curPrefix += '1'
            continue
        testB = curPrefix
        testB += '1'

        '''
        There is a word in the AD with prefix'1, so erase the next symbol
        '''
        if ad.is_af(testB):
            # print("is a word:",testB)
            decoded += '0'
            curPrefix += '0'
            continue

        '''
        There is no such word u = u'x in AD,
        where u is a suffix of current prefix. read
        input and push to output
        '''
        if (len(encoded) > 0):
            # print("no word, read and push to output")
            decoded += encoded[0]
            curPrefix += encoded[0]
            encoded = encoded[1:]
    print("Decoded: {}".format(decoded))
    return decoded


def main():
    binaryInput = input("Enter binary string to compress, or type 'exit' to quit: ")
    while binaryInput != "quit":
        print("Character count of user input: {}".format(len(binaryInput)))

        # uncomment below to test text input conversion to binary (balloons)
        # binaryInput = ''.join(format(ord(x), 'b') for x in binaryInput)
        print("User input in binary: {}".format(binaryInput))
        myTrie = SuffixTrie(binaryInput)
        myTrie.convert_AD()
        inputLength = len(binaryInput)
        encoded = encode(myTrie, binaryInput)
        compressionRatio = float(len(binaryInput)) / float(len(encoded))
        spaceSavings = float(1) - (float(len(encoded) / float(len(binaryInput))))
        print("Compression Ratio: {}".format(compressionRatio))
        print("Space savings: {}%".format(spaceSavings * 100))
        decoded = decode(myTrie, inputLength, encoded)
        print("Length of decoded: {}".format(len(decoded)))
        print("Length of original input: {}".format(len(binaryInput)))
        # uncomment below to visualize constructed suffix trie
        # print(myTrie.to_dot())
        binaryInput = input("Enter string to compress, or 'exit' to quit: ")


main()